## Choice of the Base Image

 + `NODE_VERSION` =`19.0.0-alpine3.16`

The base image `node:${NODE_VERSION}`  is selected for its lightweight nature and pre-installed Node.js, ensuring efficient and secure builds for a Node.js application. The version `NODE_VERSION` provides flexibility for using different Node.js versions as needed.

## Dockerfile Directives

+ `FROM node:${NODE_VERSION}`: Specifies the base image.
+ `WORKDIR /usr/src/app`: Sets the working directory in the container.
+ `ENV NODE_OPTIONS=--openssl-legacy-provider`: Sets an environment variable.
+ `COPY . .` and `COPY package.json package-lock.json ./`: Copies files from your host to the container.
+ `RUN npm install --production` and `RUN npm run build`: Executes commands in the container.
+ `EXPOSE 3000`: Informs Docker that the container listens on the specified network ports at runtime.
+ `CMD ["npm", "start"]`: Provides defaults for an executing container.

# Docker Compose File Explanation

This `docker-compose.yml` file defines two services: `backend` and `client`.

## Docker-compose Networking

In the `docker-compose.yml` file, a bridge network named `node-network` is created. Both the `backend` and `client` services are connected to this network, allowing them to communicate with each other.

The `ports` directive is used to map the container's ports to the host's ports. For the `backend` service, port 5000 of the container is mapped to port 5000 of the host. For the `client` service, port 3000 of the container is mapped to port 3000 of the host. This allows the application to be accessed via these ports on the host machine.

```yaml
networks:
  node-network:
    driver: bridge
```

## Docker-compose Volume Definition and Usage

In Docker Compose, volumes are defined and used via the `volumes` directive in the service definition. Volumes are used for persisting data generated by and used by Docker containers.

In the provided `docker-compose.yml` file, two types of volumes are used: bind mounts and anonymous volumes.

### Bind Mounts

A bind mount is a type of volume that maps a directory or a file from the host into a container. Any changes made to the directory or file on the host will be reflected in the container, and vice versa.

In the `backend` and `client` services, a bind mount is created from a path on the host (`./node` for `backend` and `./client` for `client`) to a path in the container (`/usr/src/app/node` for `backend` and `/usr/src/app` for `client`). This allows the application code to be shared between the host and the container.

```yaml
volumes:
  - ./node:/usr/src/app/node
  - ./client:/usr/src/app
```
### Building, Tagging, and Pushing Docker Images

Before building the Docker image, you need to navigate to the directory containing the Dockerfile. This can be done using the `cd` command.

```bash
# Navigate to the 'backend' directory
cd backend

# Or navigate to the 'client' directory
cd client

# Build the Docker image and tag it
docker build -t colllins6299/imagename:version .

# Build the Docker image, tag it, and push it to the registry
docker build -t colllins6299/imagename:version . --push

```
### Running of Containers

Running containers in Docker is done using the `docker run` command. However, when using Docker Compose, you can start all services defined in the `docker-compose.yml` file with a single command: `docker-compose up`.

```bash
# Start all services
docker-compose up -d

#start indivual services
docker-compose up -d client

docker-compose up -d backend

```
![alt text](RunningContainers.jpg)

### Docker Images screenshots
+ client

![alt text](clientDockerImage.jpg)

+ backend

![alt text](backendDockerImage.jpg)

# Explanation of the Ansible Playbook

## Order of Execution

1. **Install dependencies**: 
   - Install Git and Python3 pip to ensure the environment is ready for cloning repositories and managing Python packages.

2. **Clone GitHub repository**: 
   - Use the `git` module to clone the application repository from GitHub into the specified directory on the Vagrant VM.

3. **Include docker role**:
   - The `docker` role is included to install Docker and its dependencies, ensuring the environment can build and run Docker containers.

4. **Include frontend role**:
   - The `client` role builds and runs the Docker container for the frontend service. It builds the image from the Dockerfile located in the `client` directory of the cloned repository and runs the container, mapping the necessary ports.

5. **Include backend role**:
   - The `backend` role builds and runs the Docker container for the backend service. It builds the image from the Dockerfile located in the `backend` directory of the cloned repository and runs the container, mapping the necessary ports.

## Roles and Modules

### Docker Role
- **docker/tasks/main.yml**: This role installs Docker and its dependencies using the `apt` module, adds the Docker GPG key and repository, installs Docker CE, and installs the Docker Python module.

### Frontend Role
- **frontend/tasks/main.yml**: This role builds the Docker image for the frontend service using the `docker_image` module and runs the container using the `docker_container` module.

### Backend Role
- **backend/tasks/main.yml**: This role builds the Docker image for the backend service using the `docker_image` module and runs the container using the `docker_container` module.

The playbook ensures the application is cloned from GitHub, Docker is installed, and the frontend and backend services are set up and running in their respective containers. This setup can be accessed and verified through the browser once the playbook execution is complete.
